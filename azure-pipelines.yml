# @name: azure-pipelines.yml
# @description: ADO pipeline

#trigger:
#  branches:
#    include:
#      - main
#  paths:
#    include:
#      - changelog.xml

appendCommitMessageToRunName: false
  
name: $(Database.SID)-$(Build.BuildId)-CI

pool:
  name: $(Agent.PoolName)

variables:
- template: variables.yml

stages:
- stage: CI
  displayName: 'Build'
  jobs:
  - job: DB_CI
    displayName: 'Database CI'
    steps:

    - checkout: self

    # this task checks if liquibase is installed on the agent server
    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Checking Liquibase version"
          & "$(L_DIR)\liquibase.bat" --version
      displayName: 'Check Liquibase Version'

    # this task validates that there are errors in liquibase changelog.xml and referenced changesets
    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: | 
          $URL = "jdbc:oracle:thin:@//$(Database.Host):$(Database.Port)/$(Database.SID)"
          & "$(L_DIR)\liquibase.bat" `
            --changeLogFile=$(L_CHANGELOG_FILE) `
            --url=$URL `
            --username="$(username)" `
            --password="$(password)" `
            validate
      displayName: 'Validate Changelog'

    # this task states the number of undeployed changesets
    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: | 
          $URL = "jdbc:oracle:thin:@//$(Database.Host):$(Database.Port)/$(Database.SID)"
          & "$(L_DIR)\liquibase.bat" `
            --changeLogFile=$(L_CHANGELOG_FILE) `
            --url=$URL `
            --username="$(username)" `
            --password="$(password)" `
            status --verbose
      displayName: 'Show Pending Changesets'

    # this task reviews the SQL statements that will be executed against the database before actually applying them
    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: | 
          $URL = "jdbc:oracle:thin:@//$(Database.Host):$(Database.Port)/$(Database.SID)"
          & "$(L_DIR)\liquibase.bat" `
            --changeLogFile=$(L_CHANGELOG_FILE) `
            --url=$URL `
            --username="$(username)" `
            --password="$(password)" `
            updateSql > update-preview.sql
        workingDirectory: $(Build.SourcesDirectory)
      displayName: 'Generate SQL Preview'

    # this task checks for previous deployments
    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: | 
          $CHANGELOG_TBL = @"
            DECLARE
              V_COUNT INTEGER := 0;
              V_EXISTS INTEGER := 0;
            BEGIN
              SELECT COUNT(*) INTO V_EXISTS FROM USER_TABLES WHERE TABLE_NAME='DATABASECHANGELOG' ;

              IF V_EXISTS > 0 THEN
                EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM DATABASECHANGELOG INTO V_COUNT;
              ENF IF;

              IF V_COUNT > 0 THEN
                DBMS_OUTPUT.PUT_LINE('EXISTS')
              ELSE
                DBMS_OUTPUT.PUT_LINE('EMPTY_OR_NOT_EXISTS');
              END IF;
            END;
            /
          "@

          
          $CHANGELOG_TBL | Out-File -FilePath $(Build.SourcesDirectory)\check_changelog.sql
          $CHANGELOG_TBL_RESULT = & "$(Oracle.Home)\bin\sqlplus" -s "$(username)/$(password)@//$(Database.Host):$(Database.Port)/$(Database.SID)" "$(Build.SourcesDirectory)\check_changelog.sql"

          if ( $CHANGELOG_TBL_RESULT -match "0") {
            Write-Host "##vso[task.setvariable variable=shouldRollbackPreview]false"
          } else {
            Write-Host "##vso[task.setvariable variable=shouldRollbackPreview]true"
          }
      displayName: 'Check Previous Deployments'

    # this task reviews the SQL statements that will be executed against the database before actually applying them
    # this task only runs if there's been a previous 'liquibase update' (deployment)
    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: | 
          $URL = "jdbc:oracle:thin:@//$(Database.Host):$(Database.Port)/$(Database.SID)"
          & "$(L_DIR)\liquibase.bat" `
            --changeLogFile=$(L_CHANGELOG_FILE) `
            --url=$URL `
            --username="$(username)" `
            --password="$(password)" `
            rollbackSql 1 > rollback-preview.sql
        workingDirectory: $(Build.SourcesDirectory)
      displayName: 'Generate Rollback SQL Preview'
      condition: eq(variables['shouldRollbackPreview'], 'true')     

    # this task records metadata like build number, commit hash, timestamp, and changelog ID for traceability.
    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: | 
          $metadata = @{
            buildNumber = "$(Build.BuildNumber)"
            buildId = "$(Build.BuildId)"
            sourceBranch = "$(Build.SourceBranch)"
            commitId = "$(Build.SourceVersion)"
            buildTime = (Get-Date).ToString("s")
            changelogFile = "$(L_CHANGELOG_FILE)"
            environment = "$(Build.SourceBranchName)"
          }
          $json = $metadata | ConvertTo-Json -Depth 2
          $json | Out-File -FilePath "$(Build.SourcesDirectory)\build-metadata.json" -Encoding utf8
        workingDirectory: $(Build.SourcesDirectory)
      displayName: 'Generate Build Metadata'

    # this task builds database ci artifact
    - task: PowerShell@2
      displayName: 'Build Artifact'
      inputs:
        targetType: 'inline'
        script: |
          Copy-Item `
            -Path $(Build.SourcesDirectory)\* `
            -Destination $(Build.ArtifactStagingDirectory) `
            -Exclude "LICENSE", "lib", "CHANGELOG.md", "azure-pipelines.yml" `
            -Recurse

#    - task: ArchiveFiles@2
#      displayName: 'Archive Liquibase Changelogs'
#      inputs:
#        rootFolderOrFile: '$(Build.SourcesDirectory)'
#        includeRootFolder: false
#        archiveType: 'zip'
#        archiveFile: '$(Build.ArtifactStagingDirectory)/liquibase-release.zip'
#        replaceExistingArchive: true

    # this task publishes database ci artifact
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Artifact'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'db-ci-artifact'
        publishLocation: 'Container'